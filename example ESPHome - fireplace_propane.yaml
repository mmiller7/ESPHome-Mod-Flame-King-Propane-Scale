substitutions:
  devicename: fireplace_propane
  sensor_power_pin: D6
  status_led_pin: D5
  temp_sensor_data_pin: D7
  load_cell_analog_pin: A0

esp8266:
  board: d1_mini

esphome:
  name: ${devicename}

  on_boot:
    # priorities: https://esphome.io/api/namespaceesphome_1_1setup__priority.html#ae948d01216eb5ed6e959b44982109f5d 
    #
    # Note - we have to do this twice because BUS is for some reason higher
    # priority level than the hardware pin setup.
    #
    # This forces the pin for sensor power to be immediately set up and turned on.
    - priority: 1001
      then:
        # Turn on the pin which powers the sensors and
        # Wait for the power bus to stabilize
        # NOTE: This is especially critical for
        # the Dallas Hub to properly detect sensors.
        #   50mS - too short - not detecting
        #   60mS - seems stable in some tests
        #   120mS - allows extra buffer to stabilize
        - lambda: |-
            pinMode(${sensor_power_pin}, OUTPUT);
            digitalWrite(${sensor_power_pin}, HIGH);
            delay(1000);

    # This sets the sensor power to be on again as soon as HARDWARE initializes GPIO
    - priority: 799
      then:
        # Turn on the pin which powers the sensors
        - switch.turn_on: sensor_power

  on_shutdown:
    - priority: 700
      then:
        # Turn off the pin which powers the sensors
        - switch.turn_off: sensor_power



wifi:
  networks:
    - ssid: !secret ssid
      password: !secret password
  domain: !secret dns_suffix

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${devicename} setup"

captive_portal:

# Enable logging
logger:
  baud_rate: 0

# Enable Home Assistant API
api:

ota:
  - platform: esphome



switch:
  # Power switch to load cell and temperature sensor circuitry
  - platform: gpio
    pin: ${sensor_power_pin}
    id: sensor_power
    name: "Sensor Power"
    internal: true

  # Allow forced-reboot from HomeAssistant
  - platform: restart
    name: "${devicename} Restart"

  # Allow immediate-sleep from HomeAssistant
  # This will allow for more complex decisions
  # and longer delay to ensure sensor updates
  - platform: template
    name: "${devicename} Deep Sleep Now"
    icon: "mdi:sleep"
    turn_on_action:
      - deep_sleep.enter: do_sleep



# To use your dallas sensor, first define a dallas “hub” with a pin
# This is where the data-pin of the DS18B20 temp-sensor is connected
one_wire:
  - platform: gpio
    pin: ${temp_sensor_data_pin}



sensor:

  # Load cell amp analog signal in scale
  - platform: adc
    pin: ${load_cell_analog_pin}
    name: "${devicename} Weight Raw"
    id: ${devicename}_weight_raw
    unit_of_measurement: "lb"
    icon: "mdi:scale"
    device_class: "weight"
    state_class: "measurement"
    accuracy_decimals: 1
    update_interval: 15s
    force_update: true
    #internal: true
    filters:
      - calibrate_linear:
          # Calibration done at 70-71F
          # Zero-Weight Calibration:
          - 0.669922 -> 0.0
          # Large-Weight Calibration:
          - 0.834961 -> 68.2
      # With USB power, we can do a longer average here to reduce noise
      # Remove sliding average for battery power
      - sliding_window_moving_average:
          window_size: 20
          send_every: 15
      - lambda: return round(x);
    on_value:
      # Update the component that computes the temperature-compensated weight every time we get a new weight
      - component.update: ${devicename}_weight
      - logger.log:
          format: "*CALIBRATE Weight ADC: adc_raw=%.6f / output=%.2f lb"
          args: [ 'id(${devicename}_weight_raw).raw_state', 'id(${devicename}_weight_raw).state' ]

  # Temperature sensor
  - platform: dallas_temp
    id: ${devicename}_temperature
    name: "${devicename} Temperature"
    #internal: true
    update_interval: 15s

  # Adjustment to compute weight correction based on current temperature
  - platform: copy
    source_id: ${devicename}_temperature
    name: "${devicename} Temperature Weight Correction"
    id: ${devicename}_temperature_weight_correction
    unit_of_measurement: "lb"
    internal: true
    filters:
      - calibrate_linear:
            # Temp -> Error correction weight delta
            # Weight Calibration Temp -> 0
            - 21.9 -> 0.0
            # Colderer Temp -> +/- correction computed using known weight
            - -1.61 -> 6.7
            #- 3.3 -> 7.7
      - lambda: return round(x);
    on_value:
      - logger.log:
          format: "*CALIBRATE Temp LB-Correction: temp_raw=%.2f / output=%.2f lb"
          args: [ 'id(${devicename}_temperature_weight_correction).raw_state', 'id(${devicename}_temperature_weight_correction).state' ]

  # Final output sensor to return the temperature-compensated weight
  - platform: template
    name: "${devicename} Weight"
    id: ${devicename}_weight
    unit_of_measurement: "lb"
    icon: "mdi:scale"
    device_class: "weight"
    state_class: "measurement"
    accuracy_decimals: 1
    # This is manually updated by the adc sensor on value change
    update_interval: never
    force_update: true
    lambda: |-
      return id(${devicename}_weight_raw).state + id(${devicename}_temperature_weight_correction).state;

status_led:
  pin:
    number: ${status_led_pin}
    # inverted=true for battery
    # inverted=false for USB power
    inverted: false

# Deep sleep to save battery power
# Default to longer wake interval in case of
# connection issues and easier OTA update
deep_sleep:
  id: do_sleep
# Since it can now run on USB power, no need to limit run duration.
# Putting to sleep can still be optional, will be handled by switch
#  run_duration: "00:05:00"
  sleep_duration: "00:59:30"
